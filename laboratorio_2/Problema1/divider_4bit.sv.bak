module divider_4bit(
    input logic [3:0] dividend,
    input logic [3:0] divisor,
    output logic [3:0] quotient,
    output logic [3:0] remainder,
    output logic V, // Overflow flag
    output logic Z // Zero flag
);

    logic [7:0] quotient_reg;
    logic [3:0] remainder_reg;
    logic [3:0] dividend_copy;
    logic [3:0] divisor_copy;
    logic [3:0] temp;
    logic [3:0] temp1;
    
    always_comb begin
        // Initialize flags
        V = 1'b0;
        Z = 1'b0;

        // Check for division by zero
        if (divisor == 4'b0) begin
            Z = 1'b1;
            quotient = 4'b0;
            remainder = 4'b0;
            return;
        end

        // Perform division
        quotient_reg = 8'b0;
        remainder_reg = dividend;
        dividend_copy = dividend;
        divisor_copy = divisor;

        for (int i = 0; i < 4; i = i + 1) begin
            // Shift divisor to left
            divisor_copy = divisor << i;

            // Subtract divisor from remainder
            temp = remainder_reg;
            if (remainder_reg >= divisor_copy) begin
                remainder_reg = remainder_reg - divisor_copy;
                quotient_reg[7-i] = 1'b1;
            end else
                quotient_reg[7-i] = 1'b0;
        end

        // Check for Overflow
        if (quotient_reg[7:4] != 4'b0)
            V = 1'b1;
        
        // Convert to 4-bit
        quotient = quotient_reg[3:0];
        remainder = remainder_reg;
    end
endmodule
